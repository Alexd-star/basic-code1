package cn.itcast.day10.demo04;
/*
代码当中体现多态性，其实就是一句话，父类引用指向子类对象

格式：
父类名称 对象名 = new 子类名称();
接口名称 对象名 = new 实现类名称();

多态：左父右子，右侧子类对象被当作父类来使用（猫被当作动物）多态性

多态执行问题
“成员变量，静态方法看左边；非静态方法：编译看左边，运行看右边。”

意思是：
当父类变量引用子类对象时（Fu f = new Zi();）
====》“ 拥有了被Zi类函数覆盖后的Fu类对象----f ”《====

所以f代表的是函数被复写后(多态的意义)的一个Fu类
（动物类被复写成了一只猫）

在这个引用变量f指向的对象中，他的成员变量和静态方法与父类是一致的，
他的非静态方法，在编译时是与父类一致的，运行时却与子类一致（发生了复写）。

向上转型一定是安全的，正确的，但是也有一个弊端：
对象一旦向上转型为父类，那么就无法调用子类原本特有的内容

向下转型：“还原”动作
 */
public class Demo01Multi {
    public static void main(String[] args) {
        //使用多态的写法
        //左侧父类的引用，指向右侧的子类对象
        Fu obj = new Zi();
        obj.method();
        obj.methodFu();
    }

}
